<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>API References &#8212; mf-toolkit 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=01f34227"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to mf-toolkit’s documentation!" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p># docs/source/api.rst</p>
<section id="api-references">
<h1>API References<a class="headerlink" href="#api-references" title="Link to this heading">¶</a></h1>
<p>This is the auto-generated documentation from the docstrings of the code.</p>
<section id="module-mftoolkit.MFDFA">
<span id="mfdfa-module"></span><h2>MFDFA module<a class="headerlink" href="#module-mftoolkit.MFDFA" title="Link to this heading">¶</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.MFDFA.mfdfa">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.MFDFA.</span></span><span class="sig-name descname"><span class="pre">mfdfa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scales</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_cores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segments_from_both_ends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range_for_hq</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mftoolkit/MFDFA.html#mfdfa"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.MFDFA.mfdfa" title="Link to this definition">¶</a></dt>
<dd><p>Performs Multifractal Detrended Fluctuations Analysis (MFDFA) in parallel.</p>
<section id="parameters">
<h3>Parameters:<a class="headerlink" href="#parameters" title="Link to this heading">¶</a></h3>
<dl class="simple">
<dt>data<span class="classifier">array_like</span></dt><dd><p>The time series to analyze (one-dimensional).</p>
</dd>
<dt>q_values<span class="classifier">array_like</span></dt><dd><p>The range of q moments for the analysis.</p>
</dd>
<dt>scales<span class="classifier">array_like</span></dt><dd><p>The scales (segment lengths) to consider. Must be integers.</p>
</dd>
<dt>order<span class="classifier">int, optional</span></dt><dd><p>The order of the polynomial for detrending (default is 1, linear).</p>
</dd>
<dt>num_cores<span class="classifier">int, optional</span></dt><dd><p>Number of CPU cores to use. If None, use os.cpu_count().</p>
</dd>
<dt>segments_from_both_ends<span class="classifier">bool, optional</span></dt><dd><p>If True, segments are taken from the start and end of the series.
If False (default) segments are taken only from the start.</p>
</dd>
<dt>scale_range_for_hq<span class="classifier">tuple or list, optional</span></dt><dd><p>Tuple (min_s, max_s) defines the scale range to be used to calculate
the exponent h(q). If None (default), all valid scales are used.</p>
</dd>
</dl>
</section>
<section id="return">
<h3>Return:<a class="headerlink" href="#return" title="Link to this heading">¶</a></h3>
<dl class="simple">
<dt>q<span class="classifier">ndarray</span></dt><dd><p>q-values valid for the time series</p>
</dd>
<dt>h_q<span class="classifier">ndarray</span></dt><dd><p>The generalized Hurst exponent for each value of q.</p>
</dd>
<dt>tau_q<span class="classifier">ndarray</span></dt><dd><p>The mass scaling function for each value of q.</p>
</dd>
<dt>alpha<span class="classifier">ndarray</span></dt><dd><p>The singularity (or Hölder) exponent.</p>
</dd>
<dt>f_alpha<span class="classifier">ndarray</span></dt><dd><p>The singularity spectrum.</p>
</dd>
<dt>F_q_s<span class="classifier">ndarray</span></dt><dd><p>The fluctuation function F_q(s) for each q and s..</p>
</dd>
</dl>
</section>
</dd></dl>

</section>
<section id="module-mftoolkit.mfsources">
<span id="sources-module"></span><h2>Sources module<a class="headerlink" href="#module-mftoolkit.mfsources" title="Link to this heading">¶</a></h2>
<p>Created on Fri Jun 27 10:14:32 2025</p>
<p>&#64;author: Nahuel Mendez &amp; Sebastian Jaroszewicz</p>
<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.mfsources.generate_iaaft_surrogate">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.mfsources.</span></span><span class="sig-name descname"><span class="pre">generate_iaaft_surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_surrogates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detrend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mftoolkit/mfsources.html#generate_iaaft_surrogate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.mfsources.generate_iaaft_surrogate" title="Link to this definition">¶</a></dt>
<dd><p>Generates multiple surrogate time series using the IAAFT algorithm in parallel
and returns the average of all generated surrogates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_data</strong> (<em>array_like</em>) – The 1D input time series to create surrogates from.</p></li>
<li><p><strong>num_surrogates</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of surrogate time series to generate before averaging.
Default is 50.</p></li>
<li><p><strong>detrend</strong> (<em>bool</em><em>, </em><em>optional</em>) – Specifies whether the time series has to be detrended prior to
surrogate generation. Default is False.</p></li>
<li><p><strong>verbose</strong> (<em>bool</em><em>, </em><em>optional</em>) – Sets the verbosity of the function. If True (default), progress
messages are displayed.</p></li>
<li><p><strong>n_jobs</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of CPU cores to use for parallel generation. -1 means
using all available cores. Default is -1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A single 1D array representing the average of all generated surrogates.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses the ‘joblib’ library for parallel processing to speed up
the generation of multiple independent surrogates. Each surrogate preserves
the power spectrum and amplitude distribution of the original series.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Schreiber, T., &amp; Schmitz, A. (1996). Improved surrogate data for</dt><dd><p>nonlinearity tests. Physical review letters, 77(4), 635.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.mfsources.iaaft_surrogate">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.mfsources.</span></span><span class="sig-name descname"><span class="pre">iaaft_surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-06</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="reference internal" href="_modules/mftoolkit/mfsources.html#iaaft_surrogate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.mfsources.iaaft_surrogate" title="Link to this definition">¶</a></dt>
<dd><p>Generate a surrogate time series using the IAAFT algorithm.</p>
<p>This method creates a surrogate series that has the same power spectrum
(and thus the same linear autocorrelation) and the same amplitude
distribution (histogram) as the original series. It is used to create
a null model for hypothesis testing, where any nonlinear structure
present in the original data is destroyed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_series</strong> (<em>array_like</em>) – The 1D input time series to create a surrogate from.</p></li>
<li><p><strong>max_iter</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum number of iterations for the IAAFT algorithm.
Defaults to 1000.</p></li>
<li><p><strong>tol</strong> (<em>float</em><em>, </em><em>optional</em>) – Tolerance for convergence. The iteration stops if the relative
change in the spectrum error is less than this value.
Defaults to 1e-8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The generated surrogate time series.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Iterative Amplitude Adjusted Fourier Transform (IAAFT) algorithm is
an improvement over the simple phase-randomized surrogate method.
It iteratively adjusts the surrogate’s amplitudes to match the original
distribution and adjusts the surrogate’s power spectrum to match the
original spectrum, providing a more accurate surrogate for hypothesis
testing against a linear stochastic process with possible non-Gaussian
distribution of values [1].</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Schreiber, T., &amp; Schmitz, A. (2000). Surrogate time series.</dt><dd><p>Physica D: Nonlinear Phenomena, 142(3-4), 346-382.
doi:10.1016/s0167-2789(00)00043-9</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.mfsources.shuffle_surrogate">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.mfsources.</span></span><span class="sig-name descname"><span class="pre">shuffle_surrogate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">original_series</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_shuffles</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="_modules/mftoolkit/mfsources.html#shuffle_surrogate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.mfsources.shuffle_surrogate" title="Link to this definition">¶</a></dt>
<dd><p>Generate surrogate time series by randomly shuffling the original series.</p>
<p>This method creates surrogate series that have the exact same amplitude
distribution (histogram) as the original series. However, it destroys all
temporal structures, including both linear and non-linear correlations,
by randomly reordering the data points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>original_series</strong> (<em>array_like</em>) – The 1D input time series to create surrogates from.</p></li>
<li><p><strong>num_surrogates</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of shuffled surrogate series to generate.
Defaults to 100.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the generated surrogate time series. Each element
of the list is a NumPy array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list of np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Shuffled surrogates are used to test the null hypothesis (H0) that the
observed data is indistinguishable from an Independent and Identically
Distributed (IID) random process. If a metric calculated on the
original series falls outside the distribution of the same metric
calculated on these surrogates, it suggests the presence of some form of
temporal structure or memory in the data.
This is a less constrained null hypothesis than that of IAAFT surrogates,
which preserve the linear correlation (power spectrum).</p>
</dd></dl>

</section>
<section id="module-mftoolkit.crossovers">
<span id="crossovers-module"></span><h2>Crossovers module<a class="headerlink" href="#module-mftoolkit.crossovers" title="Link to this heading">¶</a></h2>
<p>Created on Wed Jun 18 12:49:42 2025</p>
<p>&#64;author: Nahuel Mendez &amp; Sebastian Jaroszewicz</p>
<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.crossovers.CDVA">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.crossovers.</span></span><span class="sig-name descname"><span class="pre">CDVA</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logFq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_column</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_numba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mftoolkit/crossovers.html#CDVA"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.crossovers.CDVA" title="Link to this definition">¶</a></dt>
<dd><p>Crossover Detection based on Variance of slope Differences (CDV-A).</p>
<p>This function implements the CDV-A algorithm [1] to find the most
prominent crossover point in a log-log plot of fluctuation functions
Fq(s) vs. scales s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logS</strong> (<em>array_like</em>) – 1D array of the logarithm of the scales.</p></li>
<li><p><strong>logFq</strong> (<em>array_like</em>) – 2D array of the logarithm of the fluctuation functions.
Rows correspond to scales, columns to q-moments.</p></li>
<li><p><strong>q</strong> (<em>array_like</em>) – 1D array of the q-moments.</p></li>
<li><p><strong>method</strong> (<em>{1</em><em>, </em><em>2}</em><em>, </em><em>optional</em>) – Method to use: 1 for averaging over all q-moments, 2 for using
only q=2. Default is 1.</p></li>
<li><p><strong>q_column</strong> (<em>int</em><em>, </em><em>optional</em>) – 0-based index of the column to use in logFq when method=2.
If None, the column closest to q=2 is found automatically.</p></li>
<li><p><strong>use_numba</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, attempts to use the Numba-optimized engine for speed.
If Numba is not installed, it will fall back to the plain NumPy version.
Defaults to False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing:
- index_s_cross (int): 0-based index of the crossover in the logS array.
- slope_dif_mean (float): Mean of the slope differences at the crossover.
- i_cut (int): Row index used to trim noise-affected variances.
- valley (ndarray): Array of column indices forming the detected valley.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The CDV-A method identifies potential crossover regions by analyzing the
variance of the differences between left-side and right-side log-log
slopes, computed across multiple window sizes. This implementation is
based on the description and MATLAB code provided in [1].</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Moreno-Pulido, S., de la Torre, J.C., Ruiz, P. et al. Crossover</dt><dd><p>detection based on variances of slope differences for multi-fractal
detrended fluctuation analysis (MF-DFA). Nonlinear Dyn 113,
7425–7457 (2025). <a class="reference external" href="https://doi.org/10.1007/s11071-024-10478-1">https://doi.org/10.1007/s11071-024-10478-1</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.crossovers.SPIC">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.crossovers.</span></span><span class="sig-name descname"><span class="pre">SPIC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_k_to_test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_permutations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_points_per_segment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">significance_level</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_numba</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mftoolkit/crossovers.html#SPIC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.crossovers.SPIC" title="Link to this definition">¶</a></dt>
<dd><p>Finds the best number of crossovers (K) using a sequential permutation test.
SPIC: Sequential Permutation for Identifying Crossovers.
Allows selecting between a Numba-optimized engine or a Scikit-learn based one.</p>
<section id="id1">
<h3>Parameters:<a class="headerlink" href="#id1" title="Link to this heading">¶</a></h3>
<dl class="simple">
<dt>x_obs, y_obs<span class="classifier">array_like</span></dt><dd><p>The observed independent and dependent variables.</p>
</dd>
<dt>max_k_to_test<span class="classifier">int, optional</span></dt><dd><p>The maximum number of crossovers (K) to test for. Default is 3.</p>
</dd>
<dt>num_permutations<span class="classifier">int, optional</span></dt><dd><p>Number of permutations for the significance test. Default is 200.</p>
</dd>
<dt>min_points_per_segment<span class="classifier">int, optional</span></dt><dd><p>Minimum number of data points required in each linear segment. Default is 3.</p>
</dd>
<dt>significance_level<span class="classifier">float, optional</span></dt><dd><p>The alpha level for the permutation test. Default is 0.05.</p>
</dd>
<dt>n_jobs<span class="classifier">int, optional</span></dt><dd><p>Number of CPU cores to use for parallel permutations. -1 means all available cores. Default is -1.</p>
</dd>
<dt>use_numba<span class="classifier">bool, optional</span></dt><dd><p>If True (default), tries to use the Numba-optimized engine. If Numba is not
available, it will automatically switch to False.
If False, uses the Scikit-learn based engine.</p>
</dd>
</dl>
</section>
<section id="returns">
<h3>Returns:<a class="headerlink" href="#returns" title="Link to this heading">¶</a></h3>
<dl class="simple">
<dt>list</dt><dd><p>A list of the indices (in the sorted array) where the crossovers occur.
Returns an empty list if K=0 is the best model.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function implements the sequential hypothesis testing method using
permutations, as described in [1], to determine the optimal number of
crossovers in a piecewise linear regression model. The core idea is to
sequentially test a model with K crossovers against a model with K+1
crossovers.</p>
<p class="rubric">References</p>
<dl class="simple">
<dt>[1] Ge, E., &amp; Leung, Y. (2012). Detection of crossover time scales in multifractal detrended fluctuation analysis.</dt><dd><p>Journal of Geographical Systems, 15(2), 115–147. doi:10.1007/s10109-012-0169-9</p>
</dd>
</dl>
</section>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.crossovers.find_crossover">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.crossovers.</span></span><span class="sig-name descname"><span class="pre">find_crossover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mftoolkit/crossovers.html#find_crossover"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.crossovers.find_crossover" title="Link to this definition">¶</a></dt>
<dd><p>Finds the crossover in the slope difference matrix M.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mftoolkit.crossovers.perform_permutation_test_mp">
<span class="sig-prename descclassname"><span class="pre">mftoolkit.crossovers.</span></span><span class="sig-name descname"><span class="pre">perform_permutation_test_mp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_obs_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_obs_sorted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_cache</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_permutations</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_points_per_segment</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">significance_level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_jobs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/mftoolkit/crossovers.html#perform_permutation_test_mp"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#mftoolkit.crossovers.perform_permutation_test_mp" title="Link to this definition">¶</a></dt>
<dd><p>Performs the permutation test, dispatching to the correct fitting engine.</p>
</dd></dl>

</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">mf-toolkit</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API References</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-mftoolkit.MFDFA">MFDFA module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-mftoolkit.mfsources">Sources module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-mftoolkit.crossovers">Crossovers module</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="index.html" title="previous chapter">Welcome to mf-toolkit’s documentation!</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Nahuel Mendez & Sebastian Jaroszewicz.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/api.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>